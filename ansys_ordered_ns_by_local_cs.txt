import clr
import math
import units

clr.AddReference("System.Windows.Forms")
clr.AddReference("System.Drawing")

from System.Windows.Forms import (
    Form, Label, TextBox, ComboBox, ComboBoxStyle, CheckBox, Button, ToolTip,
    DialogResult, MessageBox, MessageBoxButtons, MessageBoxIcon,
    FormStartPosition
)
from System.Drawing import Point, Size


CS_MODE_CYL = "Cylindrical"
CS_MODE_CART = "Cartesian"
AXIS_LABELS = ["+X", "-X", "+Y", "-Y", "+Z", "-Z"]

# Enum numeric values (safe fallback in IronPython)
COORD_TYPE_CART = 0
COORD_TYPE_CYL = 1
AXIS_VALUE_BY_LABEL = {
    "+X": 1, "+Y": 2, "+Z": 3,
    "-X": 4, "-Y": 5, "-Z": 6
}
AXIS_VEC_BY_LABEL = {
    "+X": [1.0, 0.0, 0.0],
    "-X": [-1.0, 0.0, 0.0],
    "+Y": [0.0, 1.0, 0.0],
    "-Y": [0.0, -1.0, 0.0],
    "+Z": [0.0, 0.0, 1.0],
    "-Z": [0.0, 0.0, -1.0]
}
NEAR_AXIS_TOL_M = 1e-6


def dot(a, b):
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]


def cross(a, b):
    return [
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]
    ]


def norm(v):
    return math.sqrt(dot(v, v))


def normalize(v):
    n = norm(v)
    if n <= 0.0:
        raise Exception("Zero-length vector.")
    return [v[0]/n, v[1]/n, v[2]/n]


def to_float(txt):
    return float(str(txt).strip().replace(",", "."))


def mesh_nodes_sel_type():
    try:
        return SelectionTypeEnum.MeshNodes
    except:
        return 1


def is_nodal_selection(loc):
    if loc is None:
        return False
    try:
        return loc.SelectionType == SelectionTypeEnum.MeshNodes
    except:
        try:
            return int(loc.SelectionType) == 1
        except:
            return False


def convert_length(value, from_unit, to_unit):
    try:
        return float(units.ConvertUnit(value, from_unit, to_unit, "Length"))
    except:
        return float(value)


def get_axis_base(label):
    return str(label)[-1].upper()


def reference_options_for_axis(axis_label):
    b = get_axis_base(axis_label)
    if b == "X":
        return ["+Y", "-Y", "+Z", "-Z"]
    if b == "Y":
        return ["+X", "-X", "+Z", "-Z"]
    return ["+X", "-X", "+Y", "-Y"]


def get_active_nodal_ns():
    active = ExtAPI.DataModel.Tree.ActiveObjects
    if active is None or len(active) != 1:
        MessageBox.Show(
            "Please select exactly one nodal Named Selection.",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Warning
        )
        return None, None

    obj = active[0]
    if obj.GetType().Name != "NamedSelection":
        MessageBox.Show(
            "Selected object is not a Named Selection.",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Warning
        )
        return None, None

    try:
        obj.Generate()
    except:
        pass

    loc = obj.Location
    if not is_nodal_selection(loc):
        MessageBox.Show(
            "Selected Named Selection must be nodal (Mesh Nodes).",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Warning
        )
        return None, None

    try:
        node_ids = [int(i) for i in loc.Ids]
    except:
        node_ids = []

    if len(node_ids) == 0:
        MessageBox.Show(
            "Selected nodal Named Selection has no nodes.",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Warning
        )
        return None, None

    return obj, node_ids


def show_input_form():
    form = Form()
    form.Text = "Ordered Node NS Input"
    form.StartPosition = FormStartPosition.CenterScreen
    form.Size = Size(460, 430)
    form.MinimizeBox = False
    form.MaximizeBox = False

    tip = ToolTip()
    tip.AutoPopDelay = 12000
    tip.InitialDelay = 250
    tip.ReshowDelay = 100
    tip.ShowAlways = True

    def cb_text(cb, default_text=""):
        try:
            t = str(cb.SelectedItem)
            if t and t != "None":
                return t
        except:
            pass
        return default_text

    y = 18

    lbl_mode = Label()
    lbl_mode.Text = "Coordinate System Type:"
    lbl_mode.Location = Point(12, y)
    lbl_mode.AutoSize = True
    form.Controls.Add(lbl_mode)

    cb_mode = ComboBox()
    cb_mode.DropDownStyle = ComboBoxStyle.DropDownList
    cb_mode.Location = Point(230, y - 3)
    cb_mode.Size = Size(210, 21)
    cb_mode.Items.Add(CS_MODE_CYL)
    cb_mode.Items.Add(CS_MODE_CART)
    cb_mode.SelectedIndex = 0
    form.Controls.Add(cb_mode)
    tip.SetToolTip(cb_mode, "Cylindrical: sort by angle. Cartesian: sort along local +X.")

    y += 38

    lbl_x = Label()
    lbl_x.Text = "Origin X [mm]:"
    lbl_x.Location = Point(12, y)
    lbl_x.AutoSize = True
    form.Controls.Add(lbl_x)

    tb_x = TextBox()
    tb_x.Text = "0"
    tb_x.Location = Point(230, y - 3)
    tb_x.Size = Size(210, 20)
    form.Controls.Add(tb_x)
    tip.SetToolTip(tb_x, "Global X coordinate of local CS origin, in mm.")

    y += 34

    lbl_y = Label()
    lbl_y.Text = "Origin Y [mm]:"
    lbl_y.Location = Point(12, y)
    lbl_y.AutoSize = True
    form.Controls.Add(lbl_y)

    tb_y = TextBox()
    tb_y.Text = "0"
    tb_y.Location = Point(230, y - 3)
    tb_y.Size = Size(210, 20)
    form.Controls.Add(tb_y)
    tip.SetToolTip(tb_y, "Global Y coordinate of local CS origin, in mm.")

    y += 34

    lbl_z = Label()
    lbl_z.Text = "Origin Z [mm]:"
    lbl_z.Location = Point(12, y)
    lbl_z.AutoSize = True
    form.Controls.Add(lbl_z)

    tb_z = TextBox()
    tb_z.Text = "0"
    tb_z.Location = Point(230, y - 3)
    tb_z.Size = Size(210, 20)
    form.Controls.Add(tb_z)
    tip.SetToolTip(tb_z, "Global Z coordinate of local CS origin, in mm.")

    y += 34

    lbl_axis = Label()
    lbl_axis.Text = "Axis / +X direction:"
    lbl_axis.Location = Point(12, y)
    lbl_axis.AutoSize = True
    form.Controls.Add(lbl_axis)

    cb_axis = ComboBox()
    cb_axis.DropDownStyle = ComboBoxStyle.DropDownList
    cb_axis.Location = Point(230, y - 3)
    cb_axis.Size = Size(210, 21)
    for a in AXIS_LABELS:
        cb_axis.Items.Add(a)
    cb_axis.SelectedIndex = 4  # +Z
    form.Controls.Add(cb_axis)
    tip.SetToolTip(cb_axis, "Cylindrical: axis direction. Cartesian: local +X direction.")

    y += 34

    lbl_ref = Label()
    lbl_ref.Text = "0° reference direction:"
    lbl_ref.Location = Point(12, y)
    lbl_ref.AutoSize = True
    form.Controls.Add(lbl_ref)

    cb_ref = ComboBox()
    cb_ref.DropDownStyle = ComboBoxStyle.DropDownList
    cb_ref.Location = Point(230, y - 3)
    cb_ref.Size = Size(210, 21)
    form.Controls.Add(cb_ref)
    tip.SetToolTip(
        cb_ref,
        "Cylindrical only. Sets where 0° starts.\nAllowed: the other two global axes (with sign)."
    )

    y += 34

    chk_reverse = CheckBox()
    chk_reverse.Text = "Reverse ordering"
    chk_reverse.Location = Point(230, y - 3)
    chk_reverse.AutoSize = True
    form.Controls.Add(chk_reverse)
    tip.SetToolTip(chk_reverse, "Cyl: clockwise <-> counterclockwise. Cart: +X <-> -X.")

    y += 34

    lbl_preview = Label()
    lbl_preview.Location = Point(12, y)
    lbl_preview.Size = Size(428, 48)
    lbl_preview.AutoSize = False
    form.Controls.Add(lbl_preview)
    tip.SetToolTip(lbl_preview, "Live interpretation of your current settings.")

    y += 62

    btn_ok = Button()
    btn_ok.Text = "OK"
    btn_ok.Location = Point(276, y)
    btn_ok.DialogResult = DialogResult.OK
    form.Controls.Add(btn_ok)

    btn_cancel = Button()
    btn_cancel.Text = "Cancel"
    btn_cancel.Location = Point(357, y)
    btn_cancel.DialogResult = DialogResult.Cancel
    form.Controls.Add(btn_cancel)

    form.AcceptButton = btn_ok
    form.CancelButton = btn_cancel

    def refresh_ref_options(*args):
        current = cb_text(cb_ref)
        cb_ref.Items.Clear()
        opts = reference_options_for_axis(cb_text(cb_axis, "+Z"))
        for opt in opts:
            cb_ref.Items.Add(opt)

        if current in opts:
            cb_ref.SelectedItem = current
        else:
            cb_ref.SelectedIndex = 0

    def refresh_mode_ui(*args):
        is_cyl = (cb_text(cb_mode, CS_MODE_CYL) == CS_MODE_CYL)
        cb_ref.Enabled = is_cyl
        lbl_ref.Enabled = is_cyl

    def update_preview(*args):
        mode = cb_text(cb_mode, CS_MODE_CYL)
        axis = cb_text(cb_axis, "+Z")
        refd = cb_text(cb_ref, "-Y")
        rev = bool(chk_reverse.Checked)
    
        if mode == CS_MODE_CYL:
            order_txt = "counterclockwise" if rev else "clockwise"
            opposite_txt = "clockwise" if rev else "counterclockwise"
    
            lbl_preview.Text = (
                "Preview: Cylindrical\n"
                "View from {0} tip toward origin ({0} points toward you).\n"
                "0° starts at {1}; order is {2} in this view.\n"
                "From the opposite side, it appears {3}."
            ).format(axis, refd, order_txt, opposite_txt)
        else:
            direction = "largest to smallest" if rev else "smallest to largest"
            lbl_preview.Text = (
                "Preview: Cartesian\n"
                "Local +X is along {0}. Nodes are ordered by local X from {1}."
            ).format(axis, direction)


    cb_axis.SelectedIndexChanged += refresh_ref_options
    cb_axis.SelectedIndexChanged += update_preview
    cb_mode.SelectedIndexChanged += refresh_mode_ui
    cb_mode.SelectedIndexChanged += update_preview
    cb_ref.SelectedIndexChanged += update_preview
    chk_reverse.CheckedChanged += update_preview

    refresh_ref_options()
    refresh_mode_ui()
    update_preview()

    if form.ShowDialog() != DialogResult.OK:
        return None

    try:
        mode = cb_text(cb_mode)
        ox = to_float(tb_x.Text)
        oy = to_float(tb_y.Text)
        oz = to_float(tb_z.Text)
        axis_label = cb_text(cb_axis)
        ref_label = cb_text(cb_ref)
        reverse = bool(chk_reverse.Checked)
    except:
        MessageBox.Show(
            "Invalid input values.",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Error
        )
        return None

    return mode, ox, oy, oz, axis_label, ref_label, reverse


def create_local_cs(source_name, mode, ox_mm, oy_mm, oz_mm, axis_label):
    cs = Model.CoordinateSystems.AddCoordinateSystem()
    cs.Name = "OrderedNodesCS_{0}_{1}".format(mode, source_name)

    cs.OriginX = Quantity("{0} [mm]".format(ox_mm))
    cs.OriginY = Quantity("{0} [mm]".format(oy_mm))
    cs.OriginZ = Quantity("{0} [mm]".format(oz_mm))

    try:
        if mode == CS_MODE_CYL:
            cs.CoordinateSystemType = CoordinateSystemTypeEnum.Cylindrical
        else:
            cs.CoordinateSystemType = CoordinateSystemTypeEnum.Cartesian
    except:
        cs.CoordinateSystemType = COORD_TYPE_CYL if mode == CS_MODE_CYL else COORD_TYPE_CART

    axis_val = AXIS_VALUE_BY_LABEL[axis_label]
    try:
        cs.PrimaryAxis = axis_val
    except:
        pass

    return cs


def get_node_xyz(node_obj):
    try:
        return float(node_obj.X), float(node_obj.Y), float(node_obj.Z)
    except:
        c = node_obj.Coordinates
        return float(c[0]), float(c[1]), float(c[2])


def build_basis_cyl(axis_vec, ref_vec):
    # axis = cylindrical axis, ref = user-defined 0-degree direction
    ez = normalize(axis_vec)

    ex_proj = [
        ref_vec[0] - dot(ref_vec, ez)*ez[0],
        ref_vec[1] - dot(ref_vec, ez)*ez[1],
        ref_vec[2] - dot(ref_vec, ez)*ez[2]
    ]

    if norm(ex_proj) <= 1e-12:
        raise Exception("Reference direction is parallel to axis.")

    ex = normalize(ex_proj)
    ey = normalize(cross(ez, ex))
    return ex, ey, ez


def build_basis_cart(x_dir):
    ex = normalize(x_dir)
    ref = [0.0, 0.0, 1.0]
    if abs(dot(ex, ref)) > 0.95:
        ref = [0.0, 1.0, 0.0]
    ey = normalize(cross(ref, ex))
    ez = normalize(cross(ex, ey))
    return ex, ey, ez


def main():
    source_ns, node_ids = get_active_nodal_ns()
    if source_ns is None:
        return

    if len(node_ids) > 300:
        ans = MessageBox.Show(
            "Selected NS contains {0} nodes.\nThis is a large amount and may take time.\n\nContinue?".format(len(node_ids)),
            "Ordered Node NS",
            MessageBoxButtons.YesNo,
            MessageBoxIcon.Warning
        )
        if ans != DialogResult.Yes:
            return

    user = show_input_form()
    if user is None:
        return

    mode, ox_mm, oy_mm, oz_mm, axis_label, ref_label, reverse = user
    axis_vec = AXIS_VEC_BY_LABEL[axis_label]
    ref_vec = AXIS_VEC_BY_LABEL[ref_label]

    with Transaction():
        cs = create_local_cs(source_ns.Name, mode, ox_mm, oy_mm, oz_mm, axis_label)

    mesh = DataModel.MeshDataByName("Global")
    if mesh is None:
        MessageBox.Show(
            "Could not access mesh data via DataModel.MeshDataByName('Global').",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Error
        )
        return

    lu = DataModel.CurrentConsistentUnitFromQuantityName("Length")
    origin = [
        convert_length(ox_mm, "mm", lu),
        convert_length(oy_mm, "mm", lu),
        convert_length(oz_mm, "mm", lu)
    ]
    near_axis_tol = convert_length(NEAR_AXIS_TOL_M, "m", lu)

    try:
        if mode == CS_MODE_CYL:
            ex, ey, ez = build_basis_cyl(axis_vec, ref_vec)
        else:
            ex, ey, ez = build_basis_cart(axis_vec)
    except Exception as exn:
        MessageBox.Show(
            "Failed to define local basis:\n{0}".format(str(exn)),
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Error
        )
        return

    sortable = []
    skipped_near_axis = []
    skipped_missing = []

    for nid in node_ids:
        try:
            n = mesh.NodeById(nid)
            px, py, pz = get_node_xyz(n)
        except:
            skipped_missing.append(nid)
            continue

        vx = px - origin[0]
        vy = py - origin[1]
        vz = pz - origin[2]

        lx = vx*ex[0] + vy*ex[1] + vz*ex[2]
        ly = vx*ey[0] + vy*ey[1] + vz*ey[2]
        lz = vx*ez[0] + vy*ez[1] + vz*ez[2]

        if mode == CS_MODE_CYL:
            r = math.sqrt(lx*lx + ly*ly)
            if r <= near_axis_tol:
                skipped_near_axis.append(nid)
                continue

            theta_ccw = math.degrees(math.atan2(ly, lx))
            if theta_ccw < 0.0:
                theta_ccw += 360.0
            theta_cw = (360.0 - theta_ccw) % 360.0

            # normal: clockwise, reverse: counterclockwise
            angle_key = theta_ccw if reverse else theta_cw
            sortable.append((angle_key, r, nid))
        else:
            # normal: +X (small->large), reverse: -X (large->small)
            radial_yz = math.sqrt(ly*ly + lz*lz)
            x_key = -lx if reverse else lx
            sortable.append((x_key, radial_yz, nid))

    if len(sortable) == 0:
        MessageBox.Show(
            "No nodes available to create ordered named selections.",
            "Ordered Node NS",
            MessageBoxButtons.OK,
            MessageBoxIcon.Warning
        )
        return

    sortable.sort(key=lambda t: (t[0], t[1], t[2]))

    created = []
    width = max(3, len(str(len(sortable))))

    with Transaction():
        for i, item in enumerate(sortable):
            nid = item[2]
            ns = Model.NamedSelections.AddNamedSelection()
            sel = ExtAPI.SelectionManager.CreateSelectionInfo(mesh_nodes_sel_type())
            sel.Ids = [nid]
            ns.Location = sel
            ns.Name = "NS_BoltNode_{0}".format(str(i + 1).zfill(width))
            created.append(ns)

        folder = Model.AddTreeGroupingFolder(created)
        folder.Name = "OrderedNodes_{0}".format(source_ns.Name)

    lines = []
    lines.append("Mode: {0}".format(mode))
    lines.append("Order: {0}".format("Reversed" if reverse else "Normal"))
    lines.append("Created CS: {0}".format(cs.Name))
    lines.append("Source NS: {0}".format(source_ns.Name))
    lines.append("Input node count: {0}".format(len(node_ids)))
    lines.append("Created individual NS count: {0}".format(len(created)))
    lines.append("Group folder: {0}".format(folder.Name))

    if mode == CS_MODE_CYL:
        lines.append("0-degree reference: {0}".format(ref_label))
    if mode == CS_MODE_CYL and len(skipped_near_axis) > 0:
        lines.append("Skipped near-axis nodes (<1e-6 m): {0}".format(len(skipped_near_axis)))
    if len(skipped_missing) > 0:
        lines.append("Skipped missing mesh nodes: {0}".format(len(skipped_missing)))

    MessageBox.Show(
        "\n".join(lines),
        "Ordered Node NS",
        MessageBoxButtons.OK,
        MessageBoxIcon.Information
    )


main()
